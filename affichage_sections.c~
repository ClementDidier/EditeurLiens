#include <elf.h>
#include <stdio.h>
#include <byteswap.h>

void afficher_table_sections(FILE* elfFile)
{
	// Structure définissant l'entête du fichier .ELF
	Elf32_Ehdr elfFileHeader;

	// Structure définissant l'entête d'une section
	Elf32_Shdr elfSectionHeader;

	// Lecture de l'entête du fichier .ELF
	fread(&elfFileHeader, sizeof(Elf32_Ehdr), 1, elfFile);

	// DEBUG
	printf("Nombre de sections headers : %d\n", __bswap_16(elfFileHeader.e_shnum));

	// e_shoff : Emplacement en octets du tableau d'entêtes de sections (depuis le début du fichier)
	int headerSectionsTableOffset = elfFileHeader.e_shoff + (elfFileHeader.e_shstrndx * elfFileHeader.e_shentsize);

	// Place le curseur en lecture du stream à l'emplacement du tableau d'enetêtes de sections
	fseek(elfFile, headerSectionsTableOffset, SEEK_SET);

	// Passage de la notation big endian à little endian du nombre de sections
	int sectionsCount = __bswap_16(elfFileHeader.e_shnum);
	int s_index;
	// Lecture de chaque section et affichage
	for(s_index = 0; s_index < sectionsCount; s_index++)
	{
		// Lecture de l'entête de la section
		fread(&elfSectionHeader, sizeof(Elf32_Shdr), 1, elfFile);

		printf("sh_size : %d\n", __bswap_16(elfSectionHeader.sh_size));

		// Place le curseur à l'entête de la section d'index s_index
		//fseek(elfFile, elfFileHeader.e_shoff + s_index * elfFileHeader.e_shentsize, SEEK_SET);
		
		// Affichage des données de l'entête de la section courante
		printf("Name : %d\n", elfSectionHeader.sh_name);

		printf("Type : %s\n", sh_type(elfSectionHeader.sh_type);
	}
}

char* sh_type(Elf32_Word typeData)
{
	switch(typeData)
	{
		case 0:
			return "SHT_NULL";
			break;
		case 1:
			return "SHT_PROGBITS";
			break;
		case 2:
			return "SHT_SYMTAB";
			break;
		case 3:
			return "SHT_STRTAB";
			break;
		case 4:
			return "SHT_RELA";
			break;
		case 5:
			return "SHT_HASH";
			break;
		case 6:
			return "SHT_DYNAMIC";
			break;
		case 7:
			return "SHT_NOTE";
			break;
		case 8:
			return "SHT_NOBITS";
			break;
		case 9:
			return "SHT_REL";
			break;
		case 10:
			return "SHT_SHLIB";
			break;
		case 11:
			return "SHT_DYNSYM";
			break;
		case 0x70000000:
			return "SHT_LOPROC";
			break;
		case 0x7fffffff:
			return "SHT_HIPROC";
			break;
		case 0x80000000:
			return "SHT_LOUSER";
			break;
		case 0xffffffff:
			return "SHT_HIUSER";
			break;
		default:
			return "NULL";
	}
}
